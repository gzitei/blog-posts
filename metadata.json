{
  "posts": [
    {
      "id": "posts/remove-the-islands-with-go",
      "title": " Remove the Islands Case with Go\n\n===============================\n\nIt's been some time since I first started studying Go. Coming from a long time using Javascript for automating some tasks and creating services at my current job, my first contact with Go was simply delightful.\n\nNo types cohersion, no overnight revolution with a brand new framework, a formidable standard library... Everything looks so simple and yet so powerful.\n\nSo, in order to share my jorney learning Go and getting better with data structures and algorithms, I'll start posting somethings I've been trying with Go.\n\n The \"Remove the Islands\" case\n\nSome time ago I came accross this interview case calsse Remove the Islands: given a grid of 1 and 0 in which 1 represents land and 0 represents water, you should remove from the grid all islands, pieces of land not connected to the border. It's important to notice that elements cannot connect diagonally.\n\nThis is the input for the case:\n\n[\n    \\[1, 0, 0, 0, 0, 0\\],\n    \\[0, 1, 0, 1, 1, 1\\],\n    \\[0, 0, 1, 0, 1, 0\\],\n    \\[1, 1, 0, 0, 1, 0\\],\n    \\[1, 0, 1, 1, 0, 0\\],\n    \\[1, 0, 0, 0, 0, 1\\]\n]\n\nAnd this is the expected output:\n\n[\n    \\[1, 0, 0, 0, 0, 0\\],\n    \\[0, 0, 0, 1, 1, 1\\],\n    \\[0, 0, 0, 0, 1, 0\\],\n    \\[1, 1, 0, 0, 1, 0\\],\n    \\[1, 0, 0, 0, 0, 0\\],\n    \\[1, 0, 0, 0, 0, 1\\]\n]\n\n My solution for the case\n\nUsing Go, I've developed a solution exploring the concepts of recursion and memoization from dynamic programming.\n\nTo setup memoization, I've created two custom types: _Memo_ using a hash map where the keys represent the element's coordinates and _Board_ which represents the grid and initialized the memo variable.\n\ntype (\n    Board \\[\\]\\[\\]int\n    Memo  map\\[\\[2\\]int\\]bool\n)\n\nvar memo = Memo{}\n\nAfter that, I've declared a function responsible for checking if a given element, represented by it's coordinates _row_ and _col_, is connected to the border of the _Board_. The _increment_ parameter is used to offset the element, checking for its surroundings up, down, left and right. As neighbor elements might check the same surroundings, it's always important to check if the element to be verified is already in _memo_.\n\nfunc checkDirection(board Board, row, col int, increment map\\[byte\\]int) bool {\n    if \\_, ok := memo\\[\\[2\\]int{row, col}\\]; ok {\n    } else if col == 0 || row == 0 || col == len(board\\[row\\])-1 || row == len(board)-1 {\n        memo\\[\\[2\\]int{row, col}\\] = board\\[row\\]\\[col\\] == 1\n    } else if board\\[row\\]\\[col\\] == 0 {\n        memo\\[\\[2\\]int{row, col}\\] = false\n    } else {\n        col, row = col+increment\\['x'\\], row+increment\\['y'\\]\n        return checkDirection(board, row, col, increment)\n    }\n    return memo\\[\\[2\\]int{row, col}\\]\n}\n\nThe _checkDirection_ function allows to traverse the board, checking for each element if it's possible to find a path connecting the given element to the board passing only throgh land elements, which are represented by 1. The _connectsToBoard_ implements _checkDirection_ for each possible path to the border: up, down, left and right.\n\nfunc connectsToBorder(board Board, row, col int) bool {\n    if v, ok := memo\\[\\[2\\]int{row, col}\\]; ok {\n        return v\n    }\n    var connects bool\n    directions := \\[\\]map\\[byte\\]int{\n        {'x': -1, 'y': 0},\n        {'x': 1, 'y': 0},\n        {'x': 0, 'y': -1},\n        {'x': 0, 'y': 1},\n    }\n    for \\_, increment := range directions {\n        connects = connects || checkDirection(board, row, col, increment)\n    }\n    memo\\[\\[2\\]int{row, col}\\] = connects\n    return connects\n}\n\nIf _connectsToBorder_ returns true, it means there is at least one path of land connecting the element at position col, row to the border of the board.\n\nNow it's possible to remove all islands, traversing the board and replacing every island with water, represented by 0. The function _removeIslands_ is responsible for removing every island from the board:\n\nfunc removeIslands(board Board) {\n    result := make(Board, len(board))\n    for row := 0; row \u003c len(board); row++ {\n        result\\[row\\] = make(\\[\\]int, len(board\\[row\\]))\n        for col := 0; col \u003c len(board\\[row\\]); col++ {\n            connects := connectsToBorder(board, row, col)\n            if board\\[row\\]\\[col\\] == 1 \u0026\u0026 !connects {\n                result\\[row\\]\\[col\\] = 0\n            } else {\n                result\\[row\\]\\[col\\] = board\\[row\\]\\[col\\]\n            }\n        }\n    }\n    return result\n}\n\nUsing memoization was crucial for this case, in order to achieve a time complexity of O(n\\*m), where _n_ and _m_ represents the dimensions of the board.\n\nIf you are interested, you can check out [my solution on github](https://github.com/gzitei/just_studying/blob/main/remove-the-islands/). I'm really interested in hearing suggestions and other aproaches to solve the problem, please send me a DM with your ideas!\n",
      "raw-link": "https://raw.githubusercontent.com/gzitei/blog-posts/refs/heads/main/posts/remove-the-islands-with-go/README.md",
      "tags": [
        "#algorithm",
        "#dynamic-programming",
        "#go"
      ],
      "image": "https://raw.githubusercontent.com/gzitei/blog-posts/refs/heads/main/posts/remove-the-islands-with-go/gopher.webp"
    }
  ]
}